#!/bin/bash

echo "Arweave launch script: $0"

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PARENT_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"

$SCRIPT_DIR/check-nofile

if [ -f "${SCRIPT_DIR}/arweave" ]; then
    # If arweave exists in the current directory we are likely running from a binary release
    export ARWEAVE="${SCRIPT_DIR}/arweave"
    export ARWEAVE_COMMAND="foreground"
else
    # If arweave does not exist in the current directory we are likely running from source so
    # build a release and then copy the arweave binary to the current directory and link
    # the releases and lib directories in the parent directory. This allows the arweave
    # extended start script to run from our current directory (which is necessary for relative
    # paths to work correctly and not be relative to the rebar3 _build release directory)
    echo Building dependencies...
    (cd ${PARENT_DIR} && ./ar-rebar3 ${ARWEAVE_BUILD_TARGET:-default} release)
    export ARWEAVE="${SCRIPT_DIR}/arweave-dev"
    export ARWEAVE_COMMAND="console"
fi

if [ $# -gt 0 ] && [ `uname -s` == "Darwin" ]; then
    export RANDOMX_JIT="disable randomx_jit"
else
    export RANDOMX_JIT=
fi

export ERL_EPMD_ADDRESS=127.0.0.1
export NODE_NAME='arweave@127.0.0.1'

# +MBas aobf: emulator Memory Binary Allocation Strategy set to Address Order Best Fit
#                   https://www.erlang.org/doc/man/erts_alloc.html#strategy
# +A200: emulator number of threads in the Async long thread pool for linked in drivers; 
#        mostly unused
# +SDio200: emulator Scheduler thread count for Dirty I/O, 200 threads for file access
# +Bi: emulator Break handling: Ignore break signals
# +MBmmsbc 1024: binary_alloc maximum mseg_alloc singleblock carriers (1024 carriers, default 256).
#                Once exhausted, the emulator will start using sys_alloc rather than mseg_alloc
#                for singleblock carriers. This can be slower.
# +MBsbct 1024: binary_alloc singleblock carrier threshold (in KiB) (1MiB, default 512KiB). Blocks larger
#                  than the threshold are placed in singleblock carriers. We have so many 100MiB
#                  binary blocks due to the read recall range that it's most efficient for
#                  allocation and reuse if the singleblock carriers are uniformly that size, by
#                  increasing the threshold we force more blocks to be place in multiblock carriers.
# +MBlmbcs 10240: binary_alloc largest multipblock carrier size (in KiB) (10MiB, default 5MiB).
# +MBsmbcs 512: binary_alloc smallest multiblock carrier size (in KiB) (512KiB, default 256KiB).
#                  These two values are driven by the MBsbct value, 0.5x and 10x respectively.
#                  https://erlang-questions.erlang.narkive.com/xZoj6Fix/how-to-tune-erlang-memory-allocator-to-use-25-gb-of-ram-and-stop-munmaping-it#post8
# https://www.erlang-factory.com/static/upload/media/139454517145429lukaslarsson.pdf
# https://www.youtube.com/watch?v=nuCYL0X-8f4
# Note for testing it's sometimes useful to limit the number of schedulers that will be used,
# to do that: +S 16:16
export ARWEAVE_OPTS="+Ktrue +A200 +SDio200 \
    +MBsbct 103424 +MBsmbcs 10240 +MBlmbcs 410629 +MBmmmbc 1024 +MBas ageffcaobf \
    +sbwtvery_long +sbwtdcpuvery_long +sbwtdiovery_long \
    +swtvery_low +swtdcpuvery_low +swtdiovery_low +Bi"

echo "Arweave launch script: $ARWEAVE"
echo "Arweave launch options: $ARWEAVE_OPTS"
