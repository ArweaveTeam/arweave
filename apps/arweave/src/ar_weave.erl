-module(ar_weave).

-export([init/0, init/1, init/2, create_mainnet_genesis_txs/0, add_mainnet_v1_genesis_txs/0]).

-include_lib("arweave/include/ar.hrl").
-include_lib("arweave/include/ar_consensus.hrl").
-include_lib("arweave/include/ar_config.hrl").
-include_lib("arweave/include/ar_pricing.hrl").

-include_lib("eunit/include/eunit.hrl").

%%%===================================================================
%%% Public interface.
%%%===================================================================

%% @doc Create a genesis block. The genesis block includes one transaction with
%% at least one small chunk and the total data size equal to ?STRICT_DATA_SPLIT_THRESHOLD,
%% to test the code branches dealing with small chunks placed before the threshold.
init() ->
	init([]).

%% @doc Create a genesis block with the given accounts. One system account is added to the
%% list - we use it to sign a transaction included in the genesis block.
init(WalletList) ->
	init(WalletList, 1).

%% @doc Create a genesis block with the given accounts and difficulty.
init(WalletList, Diff) ->
	Key = ar_wallet:new_keyfile(),
	TX = create_genesis_tx(Key),
	WalletList2 = WalletList ++ [{ar_wallet:to_address(Key), 0, TX#tx.id}],
	TXs = [TX],
	WL = ar_patricia_tree:from_proplist([{A, {B, LTX}} || {A, B, LTX} <- WalletList2]),
	WLH = element(1, ar_block:hash_wallet_list(0, unclaimed, WL)),
	ok = ar_storage:write_wallet_list(WLH, WL),
	SizeTaggedTXs = ar_block:generate_size_tagged_list_from_txs(TXs, 0),
	BlockSize = case SizeTaggedTXs of [] -> 0; _ -> element(2, lists:last(SizeTaggedTXs)) end,
	SizeTaggedDataRoots = [{Root, Offset} || {{_, Root}, Offset} <- SizeTaggedTXs],
	{TXRoot, _Tree} = ar_merkle:generate_tree(SizeTaggedDataRoots),
	Timestamp = os:system_time(second),
	true = BlockSize == (3 * 262144), % Matches ?STRICT_DATA_SPLIT_THRESHOLD in tests.
	B0 =
		#block{
			txs = TXs,
			tx_root = TXRoot,
			wallet_list = WLH,
			diff = Diff,
			cumulative_diff = ar_difficulty:next_cumulative_diff(0, Diff, 0),
			weave_size = BlockSize,
			block_size = BlockSize,
			reward_pool = 0,
			timestamp = Timestamp,
			last_retarget = Timestamp,
			size_tagged_txs = SizeTaggedTXs,
			usd_to_ar_rate = ?NEW_WEAVE_USD_TO_AR_RATE,
			scheduled_usd_to_ar_rate = ?NEW_WEAVE_USD_TO_AR_RATE,
			packing_2_5_threshold = 0,
			strict_data_split_threshold = BlockSize
		},
	B1 =
		case ar_fork:height_2_6() > 0 of
			true ->
				B0;
			false ->
				B0#block{ packing_2_6_threshold = 0 }
		end,
	B2 =
		case ar_fork:height_2_7() > 0 of
			false ->
				B1#block{ nonce = 0, recall_byte = 0, partition_number = 0,
						reward_key = {{?RSA_SIGN_ALG, 65537}, <<>>}, reward_addr = <<>>,
						recall_byte2 = 0, nonce_limiter_info = #nonce_limiter_info{
								output = crypto:strong_rand_bytes(32),
								seed = crypto:strong_rand_bytes(48),
								partition_upper_bound = BlockSize,
								next_seed = crypto:strong_rand_bytes(48),
								next_partition_upper_bound = BlockSize } };
			true ->
				B1#block{ nonce = <<>> }
		end,
	[B2#block{ indep_hash = ar_block:indep_hash(B2) }].

create_genesis_tx(Key) ->
	{_, {_, Pk}} = Key,
	Size = 262144 * 3, % Matches ?STRICT_DATA_SPLIT_THRESHOLD in tests.
	UnsignedTX =
		(ar_tx:new())#tx{
			owner = Pk,
			reward = 0,
			data = crypto:strong_rand_bytes(Size),
			data_size = Size,
			target = <<>>,
			quantity = 0,
			tags = [],
			last_tx = <<>>,
			format = 1
		},
	ar_tx:sign_v1(UnsignedTX, Key).

add_mainnet_v1_genesis_txs() ->
	{ok, Files} = file:list_dir("data/genesis_txs"),
	{ok, Config} = application:get_env(arweave, config),
	lists:foldl(
		fun(F, Acc) ->
			file:copy(
				"data/genesis_txs/" ++ F,
				Config#config.data_dir ++ "/" ++ ?TX_DIR ++ "/" ++ F
			),
			[ar_util:decode(hd(string:split(F, ".")))|Acc]
		end,
		[],
		Files
	).

%% @doc Return the mainnet genesis transactions.
create_mainnet_genesis_txs() ->
	TXs = lists:map(
		fun({M}) ->
			{Priv, Pub} = ar_wallet:new(),
			LastTx = <<>>,
			Data = unicode:characters_to_binary(M),
			TX = ar_tx:new(Data, 0, LastTx),
			Reward = 0,
			SignedTX = ar_tx:sign_v1(TX#tx{reward = Reward}, Priv, Pub),
			ar_storage:write_tx(SignedTX),
			SignedTX
		end,
		?GENESIS_BLOCK_MESSAGES
	),
	ar_storage:write_file_atomic(
		"genesis_wallets.csv",
		lists:map(fun(T) -> binary_to_list(ar_util:encode(T#tx.id)) ++ "," end, TXs)
	),
	[T#tx.id || T <- TXs].
